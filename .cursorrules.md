# Cursor Rules — react-lineup-builder

> Save this file as **`.cursorrules.md`** in the repo root. These rules guide AI-assisted edits in Cursor for this project’s stack: React 19 + TypeScript 5.8 + Vite 7 + Tailwind CSS v4 + Radix UI + lucide-react + cva/clsx.

---

## Project Snapshot

- **Runtime:** React 19, React DOM 19, Vite 7, TypeScript 5.8 (ESM, `"type": "module"`).
- **UI:** Tailwind v4, Radix primitives, lucide-react icons.
- **Utilities:** `clsx`, `tailwind-merge` (`twMerge`), `class-variance-authority` (`cva`).
- **Linting:** ESLint 9 flat config (typescript-eslint), `eslint-plugin-react-hooks`, `eslint-plugin-react-refresh`.

When generating or modifying code, prefer:

- Functional components, `useState`/`useReducer`/`useRef`; avoid external state libs unless requested.
- Co-located component files: one component per folder (`ComponentName/ComponentName.tsx`, `index.ts`, optional `ComponentName.test.tsx`).
- Stable event handlers via `useCallback` only for hot paths (lists, memoized children). Don’t over-memoize.

---

## Code Style & Conventions

### TypeScript

- `strict` on; no `any`. Use `unknown` + type narrowing.
- Prefer **types** over **interfaces** for component props.
- Export component props as `ComponentNameProps`.
- No default exports for components; named exports only.

### React

- Use **Server-Safe** client-only patterns (no Next.js). All code runs in the browser.
- Hooks: follow rules-of-hooks; custom hooks in `useXyz.ts` with a clear return shape.
- Keep components pure; avoid side effects in render.
- **Lists/drag-drop**: key by stable ID, not index.

### Styling

- Tailwind-first. Minimal CSS files.
- Compose class names via `clsx` + `twMerge` helper: `cn(...classes)`.
- Use `cva` for variant-able components (size, intent, state). Put variants next to component.

```ts
// utils/cn.ts
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export const cn = (...inputs: unknown[]) => twMerge(clsx(inputs));
```

### Accessibility

- Prefer Radix primitives for semantics & focus management.
- Ensure keyboard support (Tab, Space/Enter for buttons, Arrow keys for lists when applicable).
- Provide `aria-*` labels for interactive controls; associate `<Label>` with inputs.

### Icons

- Use `lucide-react` icons; size via Tailwind (`h-4 w-4`) not inline styles.

---

## File Organization

- `src/components/*` — presentational & primitive components.
- `src/features/*` — domain features (e.g., lineup, players, positions).
- `src/hooks/*` — reusable hooks.
- `src/lib/*` — utilities (cn, cva variants, constants, types).
- `src/pages/*` or `src/app/*` depending on router choice (keep SPA for now).

Use **barrel files** (`index.ts`) only when it improves DX; avoid circular deps.

---

## Radix UI Guidance

- Wrap primitives to expose a project-consistent API (e.g., `UI/Dialog`, `UI/Checkbox`).
- Keep portals where appropriate; pass `modal` flag intentionally.
- Map Radix states to Tailwind data selectors: `[data-state=open]`, etc.

---

## Tailwind v4 Guidance

- Prefer utility classes; extract to `cva` when variant logic grows.
- Spacing scale consistent (e.g., `p-2` ≥ minimal; use responsive variants).
- Animations via `tw-animate-css` only when reusable; otherwise inline `transition` utilities.

---

## Performance & DX

- Avoid unnecessary re-renders: pass primitives, memo child components in large lists.
- Defer non-critical work with `requestIdleCallback` or `setTimeout(0)` when needed.
- Keep bundle lean—import icons by name, not `*`.

---

## Testing (lightweight)

- Prefer integration-style tests around interactive components (playground approach acceptable if no test runner is set up yet).
- If adding tests later, use Vitest + Testing Library; no Enzyme.

---

## ESLint/Type Safety Expectations

- Fix all type errors; don’t suppress with `// @ts-ignore` unless adding a TODO with context and ticket.
- Keep hooks rule enabled and satisfied.
- Prefer `satisfies` for object literals to keep wideness safe.

---

## Commit Messages

- Conventional-ish: `feat:`, `fix:`, `refactor:`, `chore:`, `docs:`, `style:`, `perf:`.

---

## What AI Should **Do**

- Generate idiomatic React 19 + TS components with Tailwind classes and Radix as needed.
- Add props with solid types and JSDoc for public primitives.
- Use `cva` for variants and `cn` helper for class merges.
- Keep components small; extract subcomponents when over \~150 LOC.
- Provide minimal examples within the component file’s bottom as story-like usage comments.

## What AI Should **NOT** Do

- Don’t introduce external state libraries, CSS-in-JS, or routing libs unless requested.
- Don’t change build tooling (Vite, TS config) unless asked.
- Don’t add heavy dependencies; prefer zero-deps helpers.
- Don’t downgrade accessibility for visuals.

---

## Reusable Primitives (Patterns)

### Button (cva + lucide)

```tsx
// src/components/ui/Button.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/cn";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-2xl font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none",
  {
    variants: {
      intent: {
        primary: "bg-black text-white hover:bg-black/90 focus:ring-black",
        secondary:
          "bg-zinc-100 text-zinc-900 hover:bg-zinc-200 focus:ring-zinc-400",
        ghost: "bg-transparent text-zinc-900 hover:bg-zinc-100",
      },
      size: {
        sm: "h-8 px-3 text-sm",
        md: "h-10 px-4 text-sm",
        lg: "h-12 px-5 text-base",
      },
    },
    defaultVariants: { intent: "primary", size: "md" },
  }
);

export type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> &
  VariantProps<typeof buttonVariants> & {
    iconLeft?: React.ReactNode;
    iconRight?: React.ReactNode;
  };

export function Button({
  className,
  intent,
  size,
  iconLeft,
  iconRight,
  ...props
}: ButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ intent, size }), className)}
      {...props}
    >
      {iconLeft}
      {props.children}
      {iconRight}
    </button>
  );
}
```

### Dialog (Radix wrapper)

```tsx
// src/components/ui/Dialog.tsx
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/cn";

export const Dialog = {
  Root: DialogPrimitive.Root,
  Trigger: DialogPrimitive.Trigger,
  Close: DialogPrimitive.Close,
  Content({
    className,
    children,
    ...props
  }: DialogPrimitive.DialogContentProps) {
    return (
      <DialogPrimitive.Portal>
        <DialogPrimitive.Overlay className="fixed inset-0 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out" />
        <DialogPrimitive.Content
          className={cn(
            "fixed left-1/2 top-1/2 w-[90vw] max-w-lg -translate-x-1/2 -translate-y-1/2 rounded-2xl bg-white p-6 shadow-xl focus:outline-none",
            className
          )}
          {...props}
        >
          {children}
          <DialogPrimitive.Close className="absolute right-3 top-3 rounded-full p-1 hover:bg-zinc-100">
            <X className="h-4 w-4" aria-hidden />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        </DialogPrimitive.Content>
      </DialogPrimitive.Portal>
    );
  },
};
```

### Checkbox (Radix wrapper)

```tsx
// src/components/ui/Checkbox.tsx
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

export interface CheckboxProps extends CheckboxPrimitive.CheckboxProps {
  label?: string;
}

export function Checkbox({ label, ...props }: CheckboxProps) {
  return (
    <label className="inline-flex items-center gap-2 select-none">
      <CheckboxPrimitive.Root
        className="size-5 rounded border border-zinc-300 data-[state=checked]:bg-black data-[state=checked]:text-white"
        {...props}
      >
        <CheckboxPrimitive.Indicator>
          <Check className="h-4 w-4" />
        </CheckboxPrimitive.Indicator>
      </CheckboxPrimitive.Root>
      {label && <span className="text-sm text-zinc-900">{label}</span>}
    </label>
  );
}
```

---

## Preferred Helper Snippets (AI may insert)

### `vite-env.d.ts`

```ts
/// <reference types="vite/client" />
```

### Path aliases (tsconfig.json)

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

### Example Component Template

```tsx
import * as React from "react";
import { cn } from "@/lib/cn";

export type {{ComponentName}}Props = {
  className?: string;
  // add props
};

export function {{ComponentName}}({ className }: {{ComponentName}}Props) {
  return (
    <div className={cn("", className)}>
      {/* content */}
    </div>
  );
}
```

---

## AI Editing Guardrails

1. **Respect existing public APIs** of exported components.
2. **Do not** alter build scripts or package manager versions.
3. **Keep imports sorted**: node built-ins → third-party → internal (`@/..`).
4. **Prefer composition** over prop drilling; avoid context unless multiple consumers.
5. **Document decisions** with short comments when trade-offs are made.

---

## Cursor Instructions (Meta)

- When a user asks for a new UI piece, generate: component file, minimal usage example, and add it to an entry page if relevant.
- When modifying a component, include a brief diff-style note summarizing changes.
- After large edits, propose quick manual checks (render, keyboard nav, focus trap) in a checklist comment.

---

## Quick Checklist for AI-generated UI

- [ ] Accessible labels and focus order
- [ ] No index keys in lists
- [ ] Tailwind classes merged via `cn()`
- [ ] Radix state data attributes used when styling interactive primitives
- [ ] Types accurate, no `any`
- [ ] No heavy deps added

---

_End of rules._
